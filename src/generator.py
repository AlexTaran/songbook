#!/usr/bin/python
# -*- coding: utf-8 -*-

#
# We are doing python because TeX is about legacy from 80's
# But we are in 2015.
#

import os
import codecs

SONGS_EXT = '.pydict'
DEFAULT_CHORUS_INDENT = '16pt'
DEFAULT_STANZA_SKIP = '10pt'
DEFAULT_FONT_SIZE = '12pt'
DEFAULT_FONT_SKIP = '12pt'

# Parses tex length. return: (number, units)
def parseLength(length):
  i = 0
  while i < len(length) and length[i] in '0123456789.': i += 1
  return (float(length[:i]), length[i:])

# Multiply tex length by koef. Returns tex length (as string)
def stretchLength(length, koef):
  l, u = parseLength(length)
  return str(l * koef) + u

def openW(fn):
  return codecs.open(fn, 'w', encoding='utf-8')

def unicodize(obj):
  if type(obj) is str:
    return obj.decode('utf-8')
  elif type(obj) is list:
    return [unicodize(o) for o in obj]
  elif type(obj) is dict:
    return dict([(k, unicodize(v)) for k, v in obj.iteritems()])
  else:
    return obj

def readDict(path):
  with codecs.open(path, encoding='utf-8') as f:
    return unicodize(eval(f.read()))

def ProcessStanzaToTeX(text):
  lines = text.split('\n')
  while lines[0].strip() == '': lines = lines[1:]
  while lines[-1].strip() == '': lines = lines[:-1]
  minindent = min([len(l) - len(l.lstrip(' ')) for l in lines])
  lines = [l[minindent:] for l in lines]
  lines = [l if len(l) > 0 else ' ' for l in lines] # empty lines will have at least one space
  for i, l in enumerate(lines):
    lines[i] = (l
      .replace('\\', '\\textbackslash') # must be the very first replacement!
      .replace('#', '\\#') # preserve sharp sign (#)
      .replace(' ', '\\ ') # preserve spaces
      .replace('{', '\\{')
      .replace('}', '\\}')
      .replace('-', '-{}')
    )
    if lines[i][-1] == '|': # Make whole line bold (chords)
      l = lines[i][:-1] # remove | sign
      while l[-2:] == '\\ ': l = l[:-2] # remove tail spaces
      lines[i] = '\\textbf{%s}' % l
  #lines = [l.replace() for l in lines]
  #lines = [l.replace() for l in lines]
  return '\\par%\n'.join(lines)

# s - song object
def contentsEntryByAuthor(s):
  if not 'author' in s:
    return s['name']
  return '%s --- %s' % (s['author'], s['name'])

def contentsEntryByName(s):
  if not 'author' in s:
    return s['name']
  return '%s (%s)' % (s['name'], s['author'])

# s - song object
def GenerateTeX(key, s):
  res = ''
  res += '% Autogenerated TeX code.\n\n'
  res += '\\phantomsection\\label{%s}\n' % key
  name = s['name']
  if 'author' in s:
    name = s['author'] + ' --- ' + s['name']
  res += '\\mysongtitle{%s}\n' % name
  fontsize = s.get('fontsize', DEFAULT_FONT_SIZE)
  fontskip = s.get('fontskip', DEFAULT_FONT_SKIP)
  # Processing stanzas
  texstanzas = []
  for st in s['stanzas']:
    texst = ProcessStanzaToTeX(st['text'])
    if st['type'] == 'couplet':
      pattern = '\\couplet{%s}'
      indent = st.get('indent', '0pt')
    elif st['type'] == 'chorus':
      pattern = '\\chorus{%s}'
      indent = st.get('indent', DEFAULT_CHORUS_INDENT)
    stfontsize = st.get('fontsize', fontsize)
    stfontskip = st.get('fontskip', fontskip)
    texst = ('\\fontsize{%s}{%s}\\fontspec{Courier New}' % (stfontsize, stfontskip)) + texst
    texst = ('\setlength\parindent{%s}' % indent) + texst
    texstanzas.append(pattern % texst)
  stanzaskip = '\\par\\vskip %s plus 0pt minus 0pt{}%%\n' % (s.get('stanzaskip', DEFAULT_STANZA_SKIP))
  # Processing right blocks
  rightblocks = []
  for rb in s.get('rightblocks', []):
    if rb['type'] == 'chord':
      rightblocks.append('\\gtab{%s}{%s}' % (rb['name'].replace('#', '\\#'), rb['spec']))
  res += '\\doublealign{' + stanzaskip.join(texstanzas) + '}{' + stanzaskip.join(rightblocks) + '}'
  return res

def Generate(songsdir, outdir):
  songfiles = [fn for fn in os.listdir(songsdir) if fn.endswith(SONGS_EXT)]
  gensongsdir = os.path.join(outdir, 'songs')
  if not os.path.exists(outdir): os.makedirs(outdir)
  if not os.path.exists(gensongsdir): os.makedirs(gensongsdir)
  songs = {}

  for songfn in songfiles:
    song = readDict(os.path.join(songsdir, songfn))
    key = songfn[:-len(SONGS_EXT)]
    texfn = key + '.tex'
    texsong = GenerateTeX(key, song)
    with openW(os.path.join(gensongsdir, texfn)) as f:
      f.write(texsong)
    songs[key] = song
  # Sorting by name and author
  keysByAuthor = sorted(songs.keys(), key=lambda s: contentsEntryByAuthor(songs[s]))
  keysByName   = sorted(songs.keys(), key=lambda s: contentsEntryByName  (songs[s]))
  # Generating resulting song list
  with openW(os.path.join(outdir, 'songlist.tex')) as f:
    f.write('% Autogenerated TeX code.\n\n')
    for songkey in keysByAuthor:
      f.write('\\songpage{%s}\n' % songkey)
  # Generating tables of contents
  with openW(os.path.join(outdir, 'contents_name.tex')) as f:
    f.write('% Autogenerated table of contents\n\n')
    for songkey in keysByName:
      f.write('\\mycontentsline{%s}{%s}\n' % (contentsEntryByName(songs[songkey]), songkey))
  with openW(os.path.join(outdir, 'contents_author.tex')) as f:
    f.write('% Autogenerated table of contents\n\n')
    for songkey in keysByAuthor:
      f.write('\\mycontentsline{%s}{%s}\n' % (contentsEntryByAuthor(songs[songkey]), songkey))




def main():
  Generate('src/songs', 'out/generated')

if __name__=="__main__":
  main()
